###位移运算符
#   <<  左移运算符，num << 1,相当于num乘以2
#   >>  右移运算符，num >> 1,相当于num除以2
#   >>> 无符号右移，忽略符号位，空位都以0补齐

#同一个类,同一个包,不同包的子类,不同包非子类
private Y
默认 Y,Y
protected Y,Y,Y
public Y,Y,Y,Y

#equals比较的是内容
#==比较的是两个引用是否指向同一个对象

###格式化时间
DateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
df.format(date)

###内部类的作用
封装;提供命名空间;方便访问外部类成员

###TCP 传输控制协议
###UDP 用户数据报协议

###String,StringBuffer,StringBuilder
String          对象是不可变的,线程安全.
StringBuffer    对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。
StringBuilder   并没有对方法进行加同步锁，所以是非线程安全的。　
操作少量的数据: 适用String
单线程操作字符串缓冲区下操作大量数据: 适用StringBuilder
多线程操作字符串缓冲区下操作大量数据: 适用StringBuffer

###java只有值传递
#数组的值传递保存的是同一个指针,所以会改变原数据

#hashCode() 的作用是获取哈希码
#重写 equals 时必须重写 hashCode 方法
#hashCode用来在加入HashSet前,判断是否重复
#两个对象有相同的 hashcode 值，它们也不一定是相等的,hashcode 只是用来缩小查找成本

###**静态编译：**在编译时确定类型，绑定对象
###**动态编译：**运行时确定类型，绑定对象

###反射
JAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；
这种动态获取的信息以及动态调用对象的方法的功能称为 java 语言的反射机制。
优点： 运行期类型的判断，动态加载类，提高代码灵活度。
缺点： 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的 java 代码要慢很多

###接口和抽象类的区别是什么?
接口的方法默认是 public，所有方法在接口中不能有实现，抽象类可以有非抽象的方法
接口中的实例变量默认是 final 类型的，而抽象类中则不一定
一个类可以实现多个接口，但最多只能实现一个抽象类
一个类实现接口的话要实现接口的所有方法，而抽象类不一定
接口不能用 new 实例化，但可以声明，但是必须引用一个实现该接口的对象 从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。
注意：Java8 后接口可以有默认实现( default )。

###Java序列化中如果有些字段不想进行序列化，怎么办？
对于不想进行序列化的变量，使用transient关键字修饰。
transient关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被transient修饰的变量值不会被持久化和恢复。
transient只能修饰变量，不能修饰类和方法。

### 获取用键盘输入常用的两种方法
方法1：通过 Scanner
Scanner input = new Scanner(System.in);
String s  = input.nextLine();
input.close();
方法2：通过 BufferedReader
BufferedReader input = new BufferedReader(new InputStreamReader(System.in));
String s = input.readLine();

###正确使用 equals 方法
Objects.equals(null,"SnailClimb");// false

###如何正确的将数组转换为ArrayList
List list = new ArrayList<>(Arrays.asList("a", "b", "c"))
//
Integer [] myArray = { 1, 2, 3 };
List myList = Arrays.stream(myArray).collect(Collectors.toList());
//基本类型也可以实现转换（依赖boxed的装箱操作）
int [] myArray2 = { 1, 2, 3 };
List myList = Arrays.stream(myArray2).boxed().collect(Collectors.toList());