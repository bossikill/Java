###ArrayBlockingQueue
#   有界队列

###虚假唤醒
#   所有的wait,await都要放在while里面

###LinkedBlockingQueue(阻塞链表队列)
#   offer(提供),队列尾部插入元素,队列满则丢弃当前元素,返回false
#   put(放),队列尾部插入元素,队列满则阻塞,直到成功
#   poll(剪短),获取队列头部获取并移除一个元素,队列为空则返回null
#   peek(偷看),获取队列头部元素不从队列移除它
#   take,获取队列头部元素并移除它,队列为空则阻塞,直到队列不为空返回元素
#   单向链表
    头(出队),尾部(入队),独占锁,AQS阻塞队列
    notEmpty(take,peek,poll),notFull(offer,put)

###ConcurrentLinkedQueue
#   底层使用单向链表数据结构保存队列元素,CAS算法,没有加锁,计算size不精确
#   node节点,head,tail,q,p
#   peek,poll/offer

###StampedLock
#   不可重入锁
#   提供三种读写模式:
    写锁writeLock
    悲观读锁readLock
    乐观读锁tryOptimisticRead

###ReentrantReadWriteLock
#   读写分离策略,允许多个线程可以同时获取读锁
#   适合读多写少

###ReentrantLock
#   可重入独占锁
#   公平锁&非公平锁(默认)

###抽象同步队列AQS

###jps，即可查看当前已启动的进程和对应的PID
#   jstack pid 是java虚拟机自带的一种堆栈跟踪工具

###LockSupport工具类
#   主要作用是挂起和唤醒线程
    唤醒需要许可证,默认线程不带许可证
    park,unpark

###CopyOnWriteArrayList
#   使用写时复制的策略来保证list的一致性
    使用了独占锁,提供弱一致性,迭代器获取的是一个快照

###longAccumulator
#   LongAdder是longAccumulator的一个特例,后者提供更强大的功能,可以自定义累加规则

###LongAdder
#   在内部维护多个Cell元素来分担对单个变量进行争夺开销(CAS)

###AtomicLong
#   原子操作类使用了CAS非阻塞算法,性能比阻塞的synchronized好,但是高并发情况下会存在性能问题
#   所以JDK8新增了操作类LongAdder

##ThreadLocalRandom
#   使用ThreadLocal让每一个线程持有一个本地的种子变量,避免了竞争.

###java.util.Random
#   生成新的随机数需要种子,种子使用了CAS操作,自旋锁重试,多线程的时候效率比较低.

###自旋锁
#   当线程在获取锁时,如果发现锁已经被其他线程占有,它不马上阻塞自己,
在不放弃CPU使用权的情况下,多次尝试获取,很有可能在后面几次尝试中其他线程已经释放了锁.
如果尝试指定次数后仍没有获取到锁则会被阻塞挂起.自旋锁是CPU时间换取线程阻塞与调度的开销.

###可重入锁
#   一个线程获取了锁,那么可以无限次数的进入被该锁锁住的代码(synchronized是可重入锁)

###独占锁
#   保证任何时候都只有一个线程能得到锁
###共享锁
#   允许多个线程同时进行读操作

###公平锁
#   最早请求锁的线程就最早获取到锁(ReentrantLock pairLock=new ReentrantLock(true))
###非公平锁
#   先来不一定先得(ReentrantLock pairLock=new ReentrantLock(false))
#   在没有公平性需求的前提下尽量使用非公平锁,公平锁会带来性能开销

###悲观锁
#   在数据被处理前先对数据进行加锁,
###乐观锁
#   在进行数据提交更新时,才会正式对数据冲突与否进行检测

###伪共享
#   当多个线程同时修改一个缓存行里面的多个变量时,由于同时只能有一个线程操作缓存行,所以相比将没一个变量放到一个缓存行,
#   性能会有所下降,这就是伪共享

###JAVA中的CAS操作
#   Compare and Swap 类似,MYSQL中手动实现的乐观锁,先比较时间戳再进行更新
#   unsafe类提供了类似的CAS操作

###volatile 关键字详解
#   https://www.cnblogs.com/dolphin0520/p/3920373.html
#   保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。
#   禁止进行指令重排序。(内存栅栏)
###什么时候使用volatile关键字
#   写入变量值不依赖变量的当前值时
#   读写变量值时没有加锁

###并发与并行的区别？
#   你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。
#   你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。
#   你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。
#   并发的关键是你有处理多个任务的能力，不一定要同时。并行的关键是你有同时处理多个任务的能力。
所以我认为它们最关键的点就是：是否是『同时』。

###线程是CPU分配的基本单位

###进程{堆,方法区,线程}
#   线程{程序计数器,栈}

###JAVA中三种线程创建方式
#   实现Runnable接口的run方法
#   继承Thread类,重写run方法
#   使用FutureTask方式

###使wait返回的方法
#   notify(),notifyAll()
#   interrupt(),抛出异常

###线程获取共享变量的监视器锁
#   synchronized代码块
#   synchronized修饰方法

###在并发编程中，我们通常会遇到以下三个问题：
#   原子性问题   类似数据库的事务,多个操作,要么全部执行,要么就都不执行
#   可见性问题   类似事务隔离界别,是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值
#   有序性问题   即程序执行的顺序按照代码的先后顺序执行(特殊情况"指令重排序")

###上下文切换时机
#   当前线程的CPU时间片使用完处于就绪状态时
#   当前线程被其他线程中断时

###死锁产生必备的四个条件
#   互斥条件
#   请求并持有
#   不可剥夺条件
#   环路等待条件